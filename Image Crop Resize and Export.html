<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VectorMotion Web</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      display: flex;
      height: 100vh;
      font-family: 'Segoe UI', sans-serif;
      background: #181818;
      color: #f0f0f0;
    }
    #toolbar {
      width: 250px;
      background: #222;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      border-right: 2px solid #333;
    }
    #toolbar button, #toolbar input[type="color"], #toolbar input[type="number"] {
      padding: 8px;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #toolbar button:hover {
      background: #444;
    }
    #canvas-container {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    canvas {
      flex: 1;
      background: #fff;
      cursor: crosshair;
    }
    #timeline {
      background: #111;
      padding: 5px;
      display: flex;
      align-items: center;
      gap: 5px;
      border-top: 2px solid #333;
    }
    #timeline button, #timeline input[type="number"] {
      padding: 5px;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #timeline button:hover {
      background: #444;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button onclick="setTool('rect')">Rect</button>
    <button onclick="setTool('circle')">Circle</button>
    <button onclick="setTool('line')">Line</button>
    <button onclick="setTool('freehand')">Freehand</button>
    <input type="color" id="colorPicker" value="#000000">
    <button onclick="saveFrame()">Save Frame</button>
    <button onclick="loadFrame()">Load Frame</button>
    <button onclick="exportSVG()">Export SVG</button>
    <button onclick="downloadProject()">Download Project</button>
    <button onclick="uploadProject()">Upload Project</button>
  </div>
  <div id="canvas-container">
    <canvas id="canvas" width="800" height="600"></canvas>
    <div id="timeline">
      <button onclick="prevFrame()">◀️</button>
      <span>Frame: <span id="frameNumber">0</span></span>
      <button onclick="nextFrame()">▶️</button>
      <button onclick="togglePlay()">⏯ Play</button>
      <label>Speed (ms): <input type="number" id="frameDelay" value="500" min="50"></label>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let currentTool = 'rect';
    let shapesByFrame = [[]];
    let currentFrame = 0;
    let isDrawing = false;
    let startX, startY;
    let color = document.getElementById('colorPicker').value;
    let isPlaying = false;
    let playInterval = null;

    document.getElementById('colorPicker').addEventListener('input', e => color = e.target.value);

    function setTool(tool) {
      currentTool = tool;
    }

    canvas.addEventListener('mousedown', (e) => {
      isDrawing = true;
      const rect = canvas.getBoundingClientRect();
      startX = e.clientX - rect.left;
      startY = e.clientY - rect.top;
      if (currentTool === 'freehand') {
        shapesByFrame[currentFrame].push({type: 'freehand', points: [[startX, startY]], color});
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDrawing) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (currentTool === 'freehand') {
        const shape = shapesByFrame[currentFrame][shapesByFrame[currentFrame].length - 1];
        shape.points.push([x, y]);
        draw();
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      if (!isDrawing) return;
      isDrawing = false;
      const rect = canvas.getBoundingClientRect();
      const endX = e.clientX - rect.left;
      const endY = e.clientY - rect.top;

      if (currentTool !== 'freehand') {
        shapesByFrame[currentFrame].push({
          type: currentTool,
          x: startX,
          y: startY,
          x2: endX,
          y2: endY,
          color
        });
      }
      draw();
    });

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (currentFrame > 0) {
        for (const s of shapesByFrame[currentFrame - 1] || []) {
          drawShape(s, 0.2);
        }
      }
      for (const shape of shapesByFrame[currentFrame] || []) {
        drawShape(shape, 1.0);
      }
    }

    function drawShape(shape, opacity) {
      ctx.globalAlpha = opacity;
      ctx.strokeStyle = shape.color;
      ctx.fillStyle = shape.color;

      if (shape.type === 'rect') {
        ctx.strokeRect(shape.x, shape.y, shape.x2 - shape.x, shape.y2 - shape.y);
      } else if (shape.type === 'circle') {
        const r = Math.hypot(shape.x2 - shape.x, shape.y2 - shape.y);
        ctx.beginPath(); ctx.arc(shape.x, shape.y, r, 0, Math.PI * 2); ctx.stroke();
      } else if (shape.type === 'line') {
        ctx.beginPath(); ctx.moveTo(shape.x, shape.y); ctx.lineTo(shape.x2, shape.y2); ctx.stroke();
      } else if (shape.type === 'freehand') {
        ctx.beginPath();
        ctx.moveTo(shape.points[0][0], shape.points[0][1]);
        for (let i = 1; i < shape.points.length; i++) {
          ctx.lineTo(shape.points[i][0], shape.points[i][1]);
        }
        ctx.stroke();
      }

      ctx.globalAlpha = 1.0;
    }

    function nextFrame() {
      currentFrame++;
      if (!shapesByFrame[currentFrame]) shapesByFrame[currentFrame] = [];
      document.getElementById('frameNumber').textContent = currentFrame;
      draw();
    }

    function prevFrame() {
      if (currentFrame > 0) currentFrame--;
      document.getElementById('frameNumber').textContent = currentFrame;
      draw();
    }

    function togglePlay() {
      if (isPlaying) {
        clearInterval(playInterval);
        isPlaying = false;
      } else {
        const delay = parseInt(document.getElementById('frameDelay').value);
        isPlaying = true;
        let f = 0;
        playInterval = setInterval(() => {
          currentFrame = f;
          document.getElementById('frameNumber').textContent = f;
          draw();
          f++;
          if (f >= shapesByFrame.length) f = 0;
        }, delay);
      }
    }

    function exportSVG() {
      const svgContent = `<svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">` +
        shapesByFrame[currentFrame].map(s => {
          if (s.type === 'rect') {
            return `<rect x="${s.x}" y="${s.y}" width="${s.x2 - s.x}" height="${s.y2 - s.y}" fill="none" stroke="${s.color}" />`;
          } else if (s.type === 'circle') {
            const r = Math.hypot(s.x2 - s.x, s.y2 - s.y);
            return `<circle cx="${s.x}" cy="${s.y}" r="${r}" fill="none" stroke="${s.color}" />`;
          } else if (s.type === 'line') {
            return `<line x1="${s.x}" y1="${s.y}" x2="${s.x2}" y2="${s.y2}" stroke="${s.color}" />`;
          } else if (s.type === 'freehand') {
            return `<polyline points="${s.points.map(p => p.join(",")).join(" ")}" fill="none" stroke="${s.color}" />`;
          }
        }).join('') + `</svg>`;
      const blob = new Blob([svgContent], {type: 'image/svg+xml'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `frame${currentFrame}.svg`;
      a.click();
    }

    function saveFrame() {
      localStorage.setItem('vectormotion', JSON.stringify(shapesByFrame));
    }

    function loadFrame() {
      const data = localStorage.getItem('vectormotion');
      if (data) {
        shapesByFrame = JSON.parse(data);
        draw();
      }
    }

    function downloadProject() {
      const blob = new Blob([JSON.stringify(shapesByFrame)], {type: 'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = "vectormotion-project.json";
      a.click();
    }

    function uploadProject() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = e => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = evt => {
          shapesByFrame = JSON.parse(evt.target.result);
          draw();
        };
        reader.readAsText(file);
      };
      input.click();
    }

    // Init default
    setTool("rect");
    draw();
  </script>
</body>
</html>
